package exp

import (
	"Container_runtime_scanner/internal/docker"
	"fmt"
	"net"
	"os"
	"strings"
)

func CheckFileExists(tmpfile string) bool {
	filePath := fmt.Sprintf("%s", tmpfile)
	fmt.Printf("检查文件: %s\n", filePath)

	// 读取文件状态
	stat, err := os.Stat(filePath)

	if err != nil {
		// 打印详细错误信息
		fmt.Printf("错误类型: %T\n", err)
		fmt.Printf("错误信息: %v\n", err)

		if os.IsNotExist(err) {
			fmt.Println("文件不存在")
			return false
		} else if os.IsPermission(err) {
			fmt.Println("权限被拒绝")
			return false
		} else {
			fmt.Println("其他错误")
			return false
		}
	}

	// 打印文件信息
	fmt.Printf("文件存在，类型: %v, 大小: %d, 修改时间: %v\n",
		stat.Mode(), stat.Size(), stat.ModTime())
	return true
}
func CheckRemoteFileExists(filePath string) bool {
	// 创建新的SSH会话
	session, err := docker.SSHClient.NewSession()
	if err != nil {
		return false
	}
	defer session.Close()

	// 执行检查文件存在的命令
	// test -e 检查文件是否存在，返回状态码 0 表示存在，其他值表示不存在
	cmd := fmt.Sprintf("test -e %s && echo 'exists' || echo 'not exists'", filePath)
	output, err := session.CombinedOutput(cmd)
	if err != nil {
		return false
	}

	// 检查输出结果
	result := strings.TrimSpace(string(output))
	return result == "exists"
}
func CheckRrverseShell(port string) bool {
	// 配置监听端口
	if len(os.Args) > 1 {
		port = os.Args[1]
	}

	// 开始监听
	fmt.Printf("Starting reverse shell handler on port %s...\n", port)
	listener, err := net.Listen("tcp", ":"+port)
	if err != nil {
		fmt.Printf("Error setting up listener: %v\n", err)
		os.Exit(1)
	}
	defer listener.Close()

	fmt.Println("Listening for incoming connections...")

	// 接受连接
	conn, err := listener.Accept()
	if err != nil {
		fmt.Printf("Error accepting connection: %v\n", err)
		os.Exit(1)
	}

	clientAddr := conn.RemoteAddr().String()
	fmt.Printf("Received connection from %s\n", clientAddr)
	return true
}
