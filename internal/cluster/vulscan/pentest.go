package vulscan

import (
	"context"
	"fmt"
	"os"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
)

// 漏洞扫描结果结构
type VulnerabilityResult struct {
	Component   string
	Name        string
	Namespace   string
	Description string
	Severity    string
}

func main() {
	// 获取配置 - 尝试从kubeconfig加载，或者使用集群内配置
	config, err := rest.InClusterConfig()
	if err != nil {
		kubeconfig := os.Getenv("KUBECONFIG")
		if kubeconfig == "" {
			kubeconfig = os.Getenv("HOME") + "/.kube/config"
		}
		config, err = clientcmd.BuildConfigFromFlags("", kubeconfig)
		if err != nil {
			fmt.Printf("无法获取Kubernetes配置: %v\n", err)
			os.Exit(1)
		}
	}

	// 创建clientset
	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		fmt.Printf("无法创建Kubernetes客户端: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("开始扫描Kubernetes集群漏洞...")
	fmt.Println("==================================")

	// 存储所有发现的漏洞
	var vulnerabilities []VulnerabilityResult
	
	// 检查是否存在默认ServiceAccount令牌自动挂载
	fmt.Println("检查默认ServiceAccount令牌自动挂载...")
	defaultSA, err := checkDefaultServiceAccounts(clientset)
	if err != nil {
		fmt.Printf("检查ServiceAccount时出错: %v\n", err)
	} else {
		vulnerabilities = append(vulnerabilities, defaultSA...)
	}

	// 检查RBAC配置
	fmt.Println("检查过度宽松的RBAC配置...")
	rbacVulns, err := checkRBACPermissions(clientset)
	if err != nil {
		fmt.Printf("检查RBAC配置时出错: %v\n", err)
	} else {
		vulnerabilities = append(vulnerabilities, rbacVulns...)
	}

	// 检查网络策略缺失
	fmt.Println("检查网络策略缺失...")
	netpolVulns, err := checkNetworkPolicies(clientset)
	if err != nil {
		fmt.Printf("检查网络策略时出错: %v\n", err)
	} else {
		vulnerabilities = append(vulnerabilities, netpolVulns...)
	}

	// 输出结果
	fmt.Println("\n==================================")
	fmt.Printf("扫描完成。发现 %d 个潜在安全问题:\n", len(vulnerabilities))
	fmt.Println("==================================")

	for i, vuln := range vulnerabilities {
		fmt.Printf("%d. [%s] %s\n", i+1, vuln.Severity, vuln.Component)
		fmt.Printf("   Namespace: %s, Name: %s\n", vuln.Namespace, vuln.Name)
		fmt.Printf("   描述: %s\n\n", vuln.Description)
	}
}

// 检查默认ServiceAccount令牌自动挂载
func checkDefaultServiceAccounts(clientset *kubernetes.Clientset) ([]VulnerabilityResult, error) {
	var results []VulnerabilityResult

	namespaces, err := clientset.CoreV1().Namespaces().List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		return nil, err
	}

	for _, ns := range namespaces.Items {
		serviceAccounts, err := clientset.CoreV1().ServiceAccounts(ns.Name).List(context.TODO(), metav1.ListOptions{})
		if err != nil {
			continue
		}

		for _, sa := range serviceAccounts.Items {
			if sa.Name == "default" {
				autoMount := true
				if sa.AutomountServiceAccountToken != nil {
					autoMount = *sa.AutomountServiceAccountToken
				}

				if autoMount {
					results = append(results, VulnerabilityResult{
						Component:   "ServiceAccount",
						Name:        sa.Name,
						Namespace:   sa.Namespace,
						Description: "默认ServiceAccount配置为自动挂载令牌，这可能导致权限提升风险",
						Severity:    "中",
					})
				}
			}
		}
	}

	return results, nil
}

// 检查过度宽松的RBAC配置
func checkRBACPermissions(clientset *kubernetes.Clientset) ([]VulnerabilityResult, error) {
	var results []VulnerabilityResult

	// 获取所有ClusterRole
	clusterRoles, err := clientset.RbacV1().ClusterRoles().List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		return nil, err
	}

	// 检查具有危险权限的ClusterRole
	for _, role := range clusterRoles.Items {
		for _, rule := range role.Rules {
			// 检查是否有"*"资源或动词
			hasWildcardResources := false
			hasWildcardVerbs := false

			for _, resource := range rule.Resources {
				if resource == "*" {
					hasWildcardResources = true
					break
				}
			}

			for _, verb := range rule.Verbs {
				if verb == "*" {
					hasWildcardVerbs = true
					break
				}
			}

			if hasWildcardResources && hasWildcardVerbs {
				// 检查这个角色是否被绑定
				bindings, err := clientset.RbacV1().ClusterRoleBindings().List(context.TODO(), metav1.ListOptions{})
				if err != nil {
					continue
				}

				for _, binding := range bindings.Items {
					if binding.RoleRef.Name == role.Name {
						results = append(results, VulnerabilityResult{
							Component:   "RBAC",
							Name:        role.Name,
							Namespace:   "cluster-wide",
							Description: fmt.Sprintf("ClusterRole '%s' 授予了过度宽松的权限，通过 '%s' 绑定到主体", role.Name, binding.Name),
							Severity:    "高",
						})
						break
					}
				}
			}
		}
	}

	return results, nil
}

// 检查网络策略缺失
func checkNetworkPolicies(clientset *kubernetes.Clientset) ([]VulnerabilityResult, error) {
	var results []VulnerabilityResult

	// 获取所有命名空间
	namespaces, err := clientset.CoreV1().Namespaces().List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		return nil, err
	}

	for _, ns := range namespaces.Items {
		// 跳过系统命名空间
		if ns.Name == "kube-system" || ns.Name == "kube-public" || ns.Name == "kube-node-lease" {
			continue
		}

		// 检查是否有网络策略
		netpols, err := clientset.NetworkingV1().NetworkPolicies(ns.Name).List(context.TODO(), metav1.ListOptions{})
		if err != nil {
			continue
		}

		if len(netpols.Items) == 0 {
			// 检查命名空间中是否有工作负载
			pods, err := clientset.CoreV1().Pods(ns.Name).List(context.TODO(), metav1.ListOptions{})
			if err != nil {
				continue
			}

			if len(pods.Items) > 0 {
				results = append(results, VulnerabilityResult{
					Component:   "NetworkPolicy",
					Name:        "缺失",
					Namespace:   ns.Name,
					Description: fmt.Sprintf("命名空间 '%s' 有工作负载但没有网络策略，可能允许未限制的通信", ns.Name),
					Severity:    "中",
				})
			}
		}
	}

	return results, nil
}
